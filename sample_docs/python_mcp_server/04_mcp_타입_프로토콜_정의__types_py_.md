# Chapter 4: MCP 타입/프로토콜 정의 (types.py)

---

## 동기 (Motivation)

MCP 서버와 클라이언트가 서로 정보를 주고받으려면, '무엇을', '어떤 구조로', '어떤 규칙대로' 보낼지 반드시 합의된 약속이 필요합니다. 이 약속이 바로 프로토콜이며, MCP에서는 `types.py` 파일이 그 역할을 합니다.  
이 파일은 서버·클라이언트가 주고받는 모든 요청(request), 응답(response), 알림(notification) 메시지의 정확한 **데이터 구조와 타입**을 정의하고 있습니다.  
만약 `types.py`의 정의를 모른다면, 상대방이 무엇을 기대하는지 몰라 메시지도 보내기 어렵고, 받은 메시지를 올바르게 해석·처리할 수도 없습니다.

마치 택배 상자 안에 어떤 물건이 어떤 방식(포장, 라벨, 바코드 등)으로 들어 있는지 약속하는 설명서를 만든다고 생각해보세요!  
이 문서(즉 types.py)가 있어야, 서로 다른 시스템들도 오해 없이 정확하게 소통할 수 있습니다.

---

## 주요 개념 (Key Ideas)

- **타입(type)**: 여기서는 메시지 각각의 필드(예: 요청 ID, 메서드 이름, 실제 데이터 등)가 어떤 ‘형태’여야 하는지, 즉 문자? 숫자? 리스트? 객체? 등등을 명확히 지정합니다.
- **프로토콜 메시지의 종류**: 요청, 응답, 알림 세 가지가 있습니다.  
  - **Request**: 질문(요청)에 대한 답을 기대할 때.
  - **Response**: 질문에 대한 대답.
  - **Notification**: 대답을 기대하지 않는, 일종의 방송/알림 메시지.
- **확장성(extra='allow')**: 의무적 필드 외에도 새로운 필드를 자유롭게 추가할 수 있게 설계(신·구 MCP 서버/클라이언트 간 확장성 보장).
- **Capability/스키마**: 서버와 클라이언트가 제공하거나 지원하는 기능, 각 리소스/툴/프롬프트의 설명과 구조, 파라미터의 의미 등을 명확하게 적어둡니다.

---

## 코드 해설 (Code Explanation)

이번 장의 목표는 거대한 `types.py` 파일을 위에서 설명한 주요 덩어리 별로 이해하는 것입니다.

### 1. MCP 메시지의 기본 구조

`types.py`는 Pydantic을 이용해 각 메시지 타입(요청/응답/알림 등)을 데이터 클래스(모델)로 정의합니다.  
이를 통해 자동으로 데이터 유효성 검사가 되고, 잘못된 메시지를 사전에 걸러낼 수 있습니다.

#### 1-1. 기본 요청/알림/응답 모델

- **Request**: 누가, 무엇을 요청하는지
- **Notification**: 대답을 기대하지 않는 방송
- **Result**: 요청의 결과(응답)

이 타입들은 모두 **제너릭(Generic) 클래스** 구조로 만들었기 때문에 백 엔드에서 필요한 파라미터 타입이나 메서드 이름이 유연하게 대입됩니다.

#### 1-2. 예시  
아래와 같이 되어 있습니다. (`Request`, `Notification`, `Result` 공통 구조)

- method: 어떤 명령/메서드 종류인지 (예: "initialize", "ping" 등)
- params: 실제 데이터(각기 다른 요청별로 다 이름, 구조 바뀜)
- _meta(옵션): 부가 정보(토큰 등)

메시지(요청/알림/응답)가 이 틀에 맞춰서 교환됩니다.

---

### 2. JSON-RPC 메시지 타입

MCP는 내부적으로 [JSON-RPC 2.0](https://www.jsonrpc.org/specification) 규약을 크게 차용합니다. 그래서 id, jsonrpc 버전, method, params 필드 등이 중요하게 포함되어 있습니다.

#### 2-1. 4가지 대표 메시지 타입

- **JSONRPCRequest**: id(요청 식별자)가 있어 반드시 응답을 기대.
- **JSONRPCResponse**: id가 있고, result 객체 반환.
- **JSONRPCNotification**: id가 없음, 응답을 기대하지 않음.
- **JSONRPCError**: 요청 실패 때 에러 정보를 담아 응답.

#### 2-2. 예시  
초기화 요청:
- jsonrpc: "2.0"
- id: 1
- method: "initialize"
- params: { ... }

오류가 날 때는 error 필드를 채웁니다.

---

### 3. Capability와 각 기능의 스키마

서버와 클라이언트가 **무엇을 지원할 수 있는지** 설명할 때 Capability(기능 선언) 모델들이 사용됩니다.

예시:
- `ClientCapabilities` / `ServerCapabilities`: 클라이언트/서버 각각 지원하는 주요/실험 기능 필드
- `ResourcesCapability`, `PromptsCapability` 등: 개별 기능의 지원 여부(bool), 구체 기능(알림 지원 등) 표기

서버/클라이언트 초기 연결 때, 서로의 Capability를 교환해서 어떤 동작이 가능한지 미리 알 수 있습니다.

---

### 4. 리소스/프롬프트/툴 데이터 구조

MCP는 파일, 이미지, 프롬프트, 툴 등 다양한 "객체"를 다룹니다.  
이 객체들은 모두 명확한 데이터 스키마(필드와 타입)를 가지고 있습니다.

#### 4-1. 리소스(Resource)  
- uri: 파일이나 데이터 식별자(주소)
- name: 이름
- description: 설명
- mimeType: 타입
- size: 크기(옵션)
- annotations: 추가 정보/레이블

#### 4-2. 프롬프트(Prompt)  
- name: 프롬프트 이름
- description: 설명
- arguments: 템플릿 인자(사용자 값 주입)

#### 4-3. 툴(Tool)  
- name: 도구 이름
- description: 설명
- inputSchema: 입력 파라미터 스키마(JSON Schema 활용)
- annotations: 추가 힌트(읽기 전용 등)

각각 리스트 API, 읽기 API, 변경 알림 API 등이 별도로 정의되어 있습니다. 이때 각 메서드에서 위 오브젝트 타입이 어떻게 쓰이는지 `types.py`에서 정해둡니다.

---

### 5. 타입 조합: 메시지 묶음(매크로 타입)

실제로 송수신하는 메시지는 위에서 정한 모델들을 일부만(또는 조합해) 사용합니다.

예시:
- **ClientRequest**: 클라이언트가 보낼 수 있는 요청 타입들만 "이나(or)"로 묶어서 하나의 타입으로 지정
- **ServerNotification**: 서버가 보낼 수 있는 알림만 묶어서 타입화

이 구조 덕분에, 송수신 허용되는 모든 메시지 타입을 한눈에 관리할 수 있습니다.

---

### 6. 기타 특징과 설계 철학

- 모든 모델은 새 필드의 자유로운 추가 허용(`extra='allow'`). 서버가 새로운 실험적 필드를 넣어도 기존 시스템이 에러 없이 수용 가능!
- Pydantic(V2)을 사용해서 실제로 인스턴스를 만들면 자동으로 타입 및 값 검증.
- 각종 상수 값(예: 에러코드, 표준 문자값)도 한곳(types.py)에서 유지.

---

## 마무리 (Wrap-up)

이번 장에서는 MCP의 실제 '언어'와도 같은 types.py 파일이 **왜 중요한지**와 **어떤 역할을 하는지**를 설명했습니다.

- types.py는 모든 프로토콜 메시지/객체/기능의 교과서입니다.
- 메시지의 데이터 구조, 필드 이름, 옵션을 정확하게 여기서 정합니다.
- 확장성을 염두에 둔 설계로, 미래 MCP 버전과 유연하게 호환됩니다.

다음 장에서는 **이런 통신용 모델들이, 실전 네트워크 전송(직접 파이프, HTTP SSE, Websocket 등)과 어떻게 연동되는지**를 살펴볼 것입니다.  
즉, types.py 모델들이 실제로 어떻게 송수신되는지, 각각의 '프로토콜 운반 수단' 들을 배울 차례입니다.

---